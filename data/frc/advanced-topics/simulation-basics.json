{
      "title": "Simulation Basics for FRC Robots"
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Robot Simulation",
      "content": "Simulation allows you to run your robot code on a computer without a physical robot. This is incredibly powerful for testing logic, debugging, and developing autonomous routines before the robot is built. WPILib provides a robust simulation framework that mimics the behavior of hardware components like motors, sensors, and the driver station.<br><br>Simulation works by creating a virtual environment where hardware inputs (voltage to motors) are processed by physics models, which then update virtual sensor outputs (encoder values, gyro angles). Your code interacts with these simulated sensors just as it would with real ones.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/introduction.html' target='_blank'>WPILib: Introduction to Robot Simulation</a>"
    },
    {
      "type": "text",
      "title": "The Simulation Loop",
      "content": "In a WPILib robot, the \"simulationPeriodic()\" method in your \"Robot\" or \"Subsystem\" classes is called every loop cycle (typically 20ms) only when running in simulation. This is where you update your physics models.<br><br><strong>Flow of Data in Simulation:</strong><br>1. <strong>Robot Code:</strong> Sets motor outputs (e.g., \"motor.set(0.5)\").<br>2. <strong>Simulation Periodic:</strong> You read these outputs, feed them into a physics model (e.g., \"DrivetrainSim\"), and advance the model by 20ms.<br>3. <strong>Model Update:</strong> The model calculates the new state (position, velocity).<br>4. <strong>Sensor Update:</strong> You update the simulated sensors (e.g., \"simEncoder.setPosition(...)\") with the new model data.<br>5. <strong>Robot Code:</strong> Reads the sensors in the next loop, perceiving the motion."
    },
    {
      "type": "code",
      "title": "Basic Drivetrain Simulation Example",
      "content": "package frc.robot.subsystems;\n\n\n\nimport com.revrobotics.spark.SparkMax;\n\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\n\n\n\nimport edu.wpi.first.hal.SimDouble;\n\nimport edu.wpi.first.hal.simulation.SimDeviceDataJNI;\n\nimport edu.wpi.first.math.system.plant.DCMotor;\n\nimport edu.wpi.first.math.util.Units;\n\nimport edu.wpi.first.wpilibj.AnalogGyro;\n\nimport edu.wpi.first.wpilibj.RobotBase;\n\nimport edu.wpi.first.wpilibj.RobotController;\n\nimport edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim;\n\nimport edu.wpi.first.wpilibj.smartdashboard.Field2d;\n\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\n\n\npublic class Drivetrain extends SubsystemBase {\n\n    // Real hardware\n\n    private final SparkMax m_leftMotor = new SparkMax(1, MotorType.kBrushless);\n\n    private final SparkMax m_rightMotor = new SparkMax(2, MotorType.kBrushless);\n\n    private final AnalogGyro m_gyro = new AnalogGyro(0);\n\n\n\n    // Simulation classes\n\n    private DifferentialDrivetrainSim m_driveSim;\n\n    private final Field2d m_field = new Field2d();\n\n\n\n    public Drivetrain() {\n\n        SmartDashboard.putData(\"Field\", m_field);\n\n\n\n        if (RobotBase.isSimulation()) {\n\n            // Create the simulation model\n\n            m_driveSim = new DifferentialDrivetrainSim(\n\n                DCMotor.getNEO(1),       // 1 NEO per side\n\n                7.29,                    // Gear ratio\n\n                7.5,                     // MOI\n\n                60.0,                    // Mass (kg)\n\n                Units.inchesToMeters(3), // Wheel radius\n\n                0.71,                    // Track width\n\n                null                     // Measurement noise\n\n            );\n\n        }\n\n    }\n\n\n\n    @Override\n\n    public void simulationPeriodic() {\n\n        // 1. Update simulation inputs from motor outputs\n\n        m_driveSim.setInputs(\n\n            m_leftMotor.get() * RobotController.getBatteryVoltage(),\n\n            m_rightMotor.get() * RobotController.getBatteryVoltage()\n\n        );\n\n\n\n        // 2. Advance the simulation by 20ms\n\n        m_driveSim.update(0.02);\n\n\n\n        // 3. Update simulated sensors\n\n        // (Note: For SparkMax/TalonFX, you might need vendor-specific sim methods)\n\n        // For this example, we assume generic encoder updates or wrapper classes\n\n        int dev = SimDeviceDataJNI.getSimDeviceHandle(\"SPARK MAX [1]\");\n\n        SimDouble position = new SimDouble(SimDeviceDataJNI.getSimValueHandle(dev, \"Position\"));\n\n        position.set(m_driveSim.getLeftPositionMeters());\n\n        \n\n        // Update Gyro\n\n        int gyroHandle = SimDeviceDataJNI.getSimDeviceHandle(\"AnalogGyro [0]\");\n\n        SimDouble angle = new SimDouble(SimDeviceDataJNI.getSimValueHandle(gyroHandle, \"Angle\"));\n\n        angle.set(-m_driveSim.getHeading().getDegrees()); // Gyro is typically inverted\n\n\n\n        // 4. Update Field2d for visualization\n\n        m_field.setRobotPose(m_driveSim.getPose());\n\n    }\n\n}"
    },
    {
      "type": "text",
      "title": "Physics Simulation Classes",
      "content": "WPILib provides several pre-built simulation classes for common mechanisms:<br><br><strong>DifferentialDrivetrainSim:</strong> Simulates a tank drive robot.<br><strong>SingleJointedArmSim:</strong> Simulates a rotating arm (like an intake or shoulder).<br><strong>ElevatorSim:</strong> Simulates a linear elevator.<br><strong>FlywheelSim:</strong> Simulates a spinning mass (shooter, intake rollers).<br><strong>DCMotorSim:</strong> Simulates a simple motor with load.<br><br>These classes handle the complex physics equations (gravity, inertia, friction, voltage-to-torque) so you don't have to."
    },
    {
      "type": "text",
      "title": "Visualizing Simulation with Field2d",
      "content": "The \"Field2d\" class is essential for visualizing where your robot thinks it is. By updating the \"Field2d\" object with your robot's odometry (or simulation pose), you can see a virtual robot moving on a virtual field in Glass, Shuffleboard, or AdvantageScope.<br><br>This is critical for testing autonomous paths. If the robot follows the path on the \"Field2d\" view, your path following logic is likely correct."
    },
    {
      "type": "rules-box",
      "title": "Simulation Best Practices",
      "subtitle": "Get the most out of simulation:",
      "items": [
        "Use RobotBase.isSimulation() to initialize sim-specific objects.",
        "Update physics models in simulationPeriodic().",
        "Use Field2d to visualize robot pose and trajectories.",
        "Tune simulation parameters (mass, gearing, MOI) to match the real robot as closely as possible.",
        "Test autonomous routines in simulation to verify logic and path following.",
        "Use AdvantageScope for advanced 3D visualization and data analysis."
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "Unit Testing",
          "id": "unit-testing"
        },
        {
          "label": "AdvantageKit",
          "id": "advantagekit"
        },
        {
          "label": "AdvantageScope",
          "id": "advantagescope"
        }
      ]
    }
  ]
}