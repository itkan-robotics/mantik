{
  "title": "Unit Testing for FRC Robot Code",
  "sections": [
    {
      "type": "text",
      "title": "What is Unit Testing?",
      "content": "Unit testing is the practice of testing individual units of source code to determine if they are fit for use. In the context of FRC, a 'unit' is typically a class, a method, or a subsystem. Unlike integration tests or full robot tests, unit tests run on your development machine (not the roboRIO) and execute in milliseconds.<br><br>Unit testing allows you to verify logic, math, and state transitions without needing a physical robot. This is crucial for catching bugs early, documenting expected behavior, and allowing for safe refactoring. For FRC, it enables testing complex logic like kinematics, state machines, and autonomous sequences before you even have a drivetrain built.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/unit-testing.html' target='_blank'>WPILib: Unit Testing</a>"
    },
    {
      "type": "text",
      "title": "Why Unit Testing is Important",
      "content": "<strong>1. Early Bug Detection:</strong> Catch logic errors, off-by-one errors, and edge cases before deploying code to the robot. This saves valuable battery/practice time.<br><br><strong>2. Safe Refactoring:</strong> When you clean up or optimize code, unit tests act as a safety net, ensuring you haven't broken existing functionality.<br><br><strong>3. Documentation:</strong> Tests serve as live documentation. A new member can look at \"DrivetrainTest\" to understand how the \"Drivetrain\" class is supposed to behave.<br><br><strong>4. Faster Feedback Loop:</strong> deploying code takes minutes; running tests takes seconds. This encourages more frequent testing and iteration.<br><br><strong>5. Testing Hard-to-Reach States:</strong> You can simulate rare error conditions (like a sensor disconnect or max current draw) that are dangerous or difficult to reproduce on a real robot."
    },
    {
      "type": "text",
      "title": "Testing Frameworks",
      "content": "WPILib projects use <strong>JUnit 5</strong> as the standard testing framework. It provides the structure for writing tests (assertions, test lifecycle methods).<br><br><strong>Mockito</strong> is typically used alongside JUnit. It allows you to create 'mock' objectsâ€”fake versions of complex dependencies like motor controllers or sensors. This lets you test your logic in isolation without needing the actual hardware libraries to be active or connected."
    },
    {
      "type": "code",
      "title": "Basic Unit Test Example",
      "content": "package frc.robot.util;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MathUtilsTest {\n\n    @Test\n    public void testClamp() {\n        // Assert that clamp(val, min, max) returns expected results\n        assertEquals(5.0, MathUtils.clamp(10.0, 0.0, 5.0), 0.001, \"Should clamp to max\");\n        assertEquals(0.0, MathUtils.clamp(-5.0, 0.0, 5.0), 0.001, \"Should clamp to min\");\n        assertEquals(3.0, MathUtils.clamp(3.0, 0.0, 5.0), 0.001, \"Should return value within range\");\n    }\n\n    @Test\n    public void testDeadband() {\n        assertEquals(0.0, MathUtils.applyDeadband(0.05, 0.1), 0.001, \"Should be zero inside deadband\");\n        assertEquals(0.5, MathUtils.applyDeadband(0.5, 0.1), 0.001, \"Should return value outside deadband\");\n    }\n}"
    },
    {
      "type": "text",
      "title": "Testing Subsystems with Mocks",
      "content": "Subsystems often depend on hardware (TalonFX, SparkMax, etc.). To test subsystem logic without hardware, use <strong>Mockito</strong> to mock these dependencies.<br><br>By mocking, you can verify that your subsystem calls the correct methods on the hardware (e.g., \"did we tell the motor to set voltage to 12V?\") without actually having a motor connected."
    },
    {
      "type": "code",
      "title": "Subsystem Test with Mockito",
      "content": "package frc.robot.subsystems;\n\nimport static org.mockito.Mockito.*;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport com.revrobotics.spark.SparkMax;\nimport frc.robot.Constants;\n\npublic class IntakeTest {\n    private SparkMax m_mockMotor;\n    private Intake m_intake;\n\n    @BeforeEach\n    void setup() {\n        // Create a mock SparkMax\n        m_mockMotor = mock(SparkMax.class);\n        // Inject the mock into the subsystem\n        m_intake = new Intake(m_mockMotor);\n    }\n\n    @Test\n    void testDeploy() {\n        m_intake.deploy();\n        // Verify the motor was set to the deploy speed\n        verify(m_mockMotor).set(Constants.Intake.kDeploySpeed);\n    }\n\n    @Test\n    void testStop() {\n        m_intake.stop();\n        // Verify the motor was stopped\n        verify(m_mockMotor).set(0.0);\n    }\n}"
    },
    {
      "type": "text",
      "title": "Testing Commands and Time",
      "content": "Commands often involve timing (e.g., \"WaitCommand\", running for a duration). WPILib's \"SimHooks\" allows you to control the robot's simulated time, letting you test time-dependent logic instantly.<br><br>You can also simulate the \"CommandScheduler\" to verify that commands finish when expected or are interrupted correctly."
    },
    {
      "type": "code",
      "title": "Command and Time Simulation",
      "content": "package frc.robot.commands;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport edu.wpi.first.wpilibj.simulation.SimHooks;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\n\npublic class CommandTest {\n    @Test\n    void testWaitCommand() {\n        CommandScheduler scheduler = CommandScheduler.getInstance();\n        WaitCommand waitCmd = new WaitCommand(2.0);\n        \n        scheduler.schedule(waitCmd);\n        scheduler.run();\n        assertTrue(scheduler.isScheduled(waitCmd), \"Command should be scheduled\");\n\n        // Advance time by 1 second\n        SimHooks.stepInTime(1.0);\n        scheduler.run();\n        assertTrue(scheduler.isScheduled(waitCmd), \"Command should still be running after 1s\");\n\n        // Advance time by another 1.1 seconds (total 2.1)\n        SimHooks.stepInTime(1.1);\n        scheduler.run();\n        assertFalse(scheduler.isScheduled(waitCmd), \"Command should finish after 2s\");\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Best Practices for FRC Unit Testing",
      "subtitle": "Follow these guidelines for effective tests:",
      "items": [
        "Isolate tests: Each test should run independently and not depend on the state of others.",
        "Mock hardware: Don't rely on real hardware classes; mock them or use simulation classes.",
        "Test edge cases: Test boundary values (0, max, min) and invalid inputs.",
        "Keep it fast: Unit tests should run instantly. If it takes seconds, it's too slow.",
        "Use dependency injection: Pass hardware objects into subsystem constructors to make mocking easier.",
        "Run often: Run tests before every commit and push."
      ]
    },
    {
      "type": "link-grid",
      "title": "Resources",
      "links": [
        {
          "label": "Simulation Basics",
          "id": "simulation-basics"
        },
        {
          "label": "Command-Based Code Organization",
          "id": "frc-code-organization"
        },
        {
          "label": "JUnit 5 Documentation",
          "url": "https://junit.org/junit5/docs/current/user-guide/"
        }
      ]
    }
  ]
}