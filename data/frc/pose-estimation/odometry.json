{
  "title": "Odometry",
  "sections": [
    {
      "type": "text",
      "title": "Introduction to Odometry",
      "content": "Odometry is a method of pose estimation that uses wheel encoders and a gyroscope to track robot movement over time. By measuring how far each wheel has rotated and the robot's heading, odometry calculates the robot's position through dead reckoning - integrating movement changes to determine current position.<br><br>Odometry provides continuous, fast updates (typically every 20ms robot loop) and doesn't require external references like cameras or field features. However, odometry accumulates error over time (drift) due to wheel slippage, encoder inaccuracy, and measurement errors. Despite this limitation, odometry is the foundation of most FRC pose estimation systems.<br><br><i><b>This lesson covers odometry for both differential drive and swerve drive robots. The code examples below show the general structure and flow - your team's drivetrain template will have the complete, hardware-specific implementation.</b></i><br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/index.html' target='_blank'>WPILib: Odometry Documentation</a>"
    },
    {
      "type": "text",
      "title": "Odometry Principles",
      "content": "Odometry works through dead reckoning - calculating position by integrating movement changes:<br><br><strong>Dead Reckoning:</strong> Starting from a known position, odometry tracks how the robot moves and updates position accordingly. Each movement (forward, backward, turning) changes the robot's pose, and these changes are accumulated to determine current position.<br><br><strong>Integrating Wheel Movements:</strong> Encoders measure how far each wheel has rotated. By knowing wheel diameter and encoder counts per revolution, odometry converts encoder readings into distance traveled.<br><br><strong>Calculating Position Changes:</strong> From wheel encoder readings and gyro heading, odometry calculates how the robot's X, Y, and heading have changed since the last update. These changes are added to the previous pose to get the new pose."
    },
    {
      "type": "text",
      "title": "Required Sensors",
      "content": "Odometry requires specific sensors to track robot movement:<br><br><strong>Wheel Encoders:</strong><br>- Measure rotation of drive wheels<br>- Can be built into motors (Talon FX, SPARK MAX) or external encoders<br>- Provide distance traveled by each wheel<br>- Must be calibrated (encoder counts per revolution, wheel diameter)<br><br><strong>Gyroscope (for Heading):</strong><br>- Measures robot rotation and heading<br>- Can be a dedicated gyro (Pigeon 2, NavX, ADXRS450)<br>- Provides absolute heading (not just change)<br>- Essential for accurate odometry, especially during turns"
    },
    {
      "type": "text",
      "title": "Differential Drive Odometry",
      "content": "Differential drive odometry uses two wheel encoders (left and right) plus a gyroscope to track robot pose.<br><br><strong>How It Works:</strong><br>- Left and right wheel encoders provide distance measurements<br>- The difference between left and right distances determines rotation<br>- The average of left and right distances determines forward movement<br>- Heading comes from the gyroscope (most accurate)<br>- Position is calculated from wheel distances and heading<br><br><strong>WPILib Support:</strong> WPILib provides the <code>DifferentialDriveOdometry</code> class that handles all the complex kinematics calculations for you."
    },
    {
      "type": "code",
      "title": "Reading Encoder Positions",
      "description": "Left and right wheel encoders provide distance measurements. Each encoder reports how many rotations the wheel has made. You read these values to track how far each wheel has traveled.",
      "content": "// Read encoder positions (how many rotations)\ndouble leftRevolutions = m_leftEncoder.getPosition();\ndouble rightRevolutions = m_rightEncoder.getPosition();"
    },
    {
      "type": "code",
      "title": "Converting Rotations to Distance",
      "description": "Encoder readings are in rotations, but odometry needs distance in meters. Convert rotations to distance by multiplying by the wheel circumference (2π × radius).",
      "content": "// Convert rotations to distance in meters\n// Distance = rotations × circumference\n// Circumference = 2π × radius\nprivate static final double kWheelRadiusMeters = 0.05; // Your wheel radius\n\ndouble leftDistance = leftRevolutions * 2.0 * Math.PI * kWheelRadiusMeters;\ndouble rightDistance = rightRevolutions * 2.0 * Math.PI * kWheelRadiusMeters;"
    },
    {
      "type": "code",
      "title": "Getting Heading from Gyroscope",
      "description": "Heading comes from the gyroscope (most accurate). The gyro provides the robot's current orientation angle, which is essential for accurate odometry, especially during turns.",
      "content": "// Get current heading from gyro\nRotation2d heading = Rotation2d.fromDegrees(m_gyro.getAngle());"
    },
    {
      "type": "code",
      "title": "Updating Odometry",
      "description": "Position is calculated from wheel distances and heading. Once you have the left distance, right distance, and heading, you update the odometry object. This is called every robot loop (20ms) to continuously track the robot's position.",
      "content": "// Update odometry with new measurements\nm_odometry.update(heading, leftDistance, rightDistance);"
    },
    {
      "type": "code",
      "title": "Initializing Differential Drive Odometry",
      "description": "When initializing odometry, you need to set up the starting state. This includes calibrating the gyro, resetting encoders to zero, and creating the odometry object with the initial heading and distances.",
      "content": "public DifferentialDrivetrain() {\n    // 1. Calibrate gyro (takes a few seconds)\n    m_gyro.calibrate();\n    \n    // 2. Reset encoders to zero (establish starting point)\n    m_leftEncoder.setPosition(0.0);\n    m_rightEncoder.setPosition(0.0);\n    \n    // 3. Create odometry object with:\n    //    - Current heading from gyro\n    //    - Current distances (both 0 at start)\n    //    - Starting pose (typically 0, 0, 0 degrees)\n    m_odometry = new DifferentialDriveOdometry(\n        Rotation2d.fromDegrees(m_gyro.getAngle()),\n        0.0,  // Left distance\n        0.0,  // Right distance\n        new Pose2d()  // Starting pose (0, 0, 0 degrees)\n    );\n}"
    },
    {
      "type": "code",
      "title": "Retrieving and Resetting Pose",
      "description": "You can retrieve the current pose at any time using <code>getPose()</code>. You can also reset odometry to a known pose (e.g., at the start of autonomous or after a vision correction) using <code>resetOdometry()</code>.",
      "content": "// GET POSE: Retrieve current robot position\npublic Pose2d getPose() {\n    return m_odometry.getPoseMeters();\n}\n\n// RESET: Set odometry to a known pose (e.g., at start of autonomous)\npublic void resetOdometry(Pose2d pose) {\n    // Get current encoder positions and heading\n    double leftRevolutions = m_leftEncoder.getPosition();\n    double rightRevolutions = m_rightEncoder.getPosition();\n    double leftDistance = leftRevolutions * 2.0 * Math.PI * kWheelRadiusMeters;\n    double rightDistance = rightRevolutions * 2.0 * Math.PI * kWheelRadiusMeters;\n    Rotation2d heading = Rotation2d.fromDegrees(m_gyro.getAngle());\n    \n    // Reset odometry to the specified pose\n    m_odometry.resetPosition(heading, leftDistance, rightDistance, pose);\n}"
    },
    {
      "type": "text",
      "title": "Swerve Drive Odometry",
      "content": "Swerve odometry is similar to differential drive odometry but accounts for the unique movement characteristics of swerve drivetrains. Swerve robots can move in any direction (holonomic movement) and rotate independently, requiring odometry that tracks individual module positions and angles.<br><br><strong>How It Works:</strong><br>- Each swerve module has a drive encoder (distance) and angle encoder (steering direction)<br>- All four module states are combined to calculate overall robot movement<br>- Gyroscope provides heading for accuracy<br>- More measurement points = higher accuracy than differential drive<br><br><strong>WPILib Support:</strong> WPILib provides the <code>SwerveDriveOdometry</code> class that handles all the complex kinematics calculations for you.<br><br>Learn more: <a href='https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-odometry.html' target='_blank'>WPILib: Swerve Drive Odometry</a>"
    },
    {
      "type": "code",
      "title": "Getting Module Positions",
      "description": "Each swerve module has a drive encoder (distance) and angle encoder (steering direction). All four module states are combined to calculate overall robot movement. You get the current position from each module, which includes both the distance traveled and the steering angle.",
      "content": "// Get current position from each module\n// Each module reports: (distance traveled, steering angle)\nfor (int i = 0; i < 4; i++) {\n    m_modulePositions[i] = m_modules[i].getPosition();\n}"
    },
    {
      "type": "code",
      "title": "Setting Up Kinematics",
      "description": "Kinematics defines where modules are relative to robot center. You need to specify the X, Y coordinates of each module relative to the robot's center. This tells the odometry system where each module is located on the robot.",
      "content": "// Robot dimensions (meters) - measure your actual robot\nprivate static final double kTrackWidth = 0.5;   // Left-right spacing\nprivate static final double kWheelBase = 0.5;    // Front-rear spacing\n\n// Define module positions relative to robot center\n// These are the X, Y coordinates of each module\nTranslation2d frontLeft = new Translation2d(kWheelBase / 2, kTrackWidth / 2);\nTranslation2d frontRight = new Translation2d(kWheelBase / 2, -kTrackWidth / 2);\nTranslation2d rearLeft = new Translation2d(-kWheelBase / 2, kTrackWidth / 2);\nTranslation2d rearRight = new Translation2d(-kWheelBase / 2, -kTrackWidth / 2);\n\n// Create kinematics object with module positions\nm_kinematics = new SwerveDriveKinematics(\n    frontLeft, frontRight, rearLeft, rearRight\n);"
    },
    {
      "type": "code",
      "title": "Updating Swerve Odometry",
      "description": "Gyroscope provides heading for accuracy. Once you have all four module positions and the heading, you update the odometry object. This combines all the module states to calculate overall robot movement.",
      "content": "// Get current heading from gyro\nRotation2d heading = Rotation2d.fromDegrees(m_gyro.getAngle());\n\n// Update odometry with new measurements\nm_odometry.update(heading, m_modulePositions);"
    },
    {
      "type": "code",
      "title": "Initializing Swerve Odometry",
      "description": "When initializing swerve odometry, you need to set up the kinematics (module positions), get initial positions from all modules, and create the odometry object with the initial heading and module positions.",
      "content": "public SwerveDrivetrain() {\n    // 1. Calibrate gyro (if needed for your gyro type)\n    m_gyro.calibrate();\n    \n    // 2. Set up kinematics (module positions)\n    // ... (see \"Setting Up Kinematics\" above)\n    \n    // 3. Get initial positions from all modules\n    for (int i = 0; i < 4; i++) {\n        m_modulePositions[i] = m_modules[i].getPosition();\n    }\n    \n    // 4. Create odometry object with:\n    //    - Kinematics (module layout)\n    //    - Current heading from gyro\n    //    - Current module positions\n    //    - Starting pose (typically 0, 0, 0 degrees)\n    m_odometry = new SwerveDriveOdometry(\n        m_kinematics,\n        Rotation2d.fromDegrees(m_gyro.getAngle()),\n        m_modulePositions,\n        new Pose2d()  // Starting pose\n    );\n}"
    },
    {
      "type": "text",
      "title": "Swerve Module Position",
      "content": "For swerve odometry, each module needs to report its <code>SwerveModulePosition</code> which contains:<br><br><strong>Module Position Components:</strong><br>- <strong>Distance:</strong> How far the module's drive wheel has traveled (meters)<br>- <strong>Angle:</strong> The module's current steering angle (Rotation2d)<br><br><strong>Reading from Modules:</strong> Each swerve module typically has a drive motor with encoder (for distance) and a CANcoder or similar sensor (for steering angle). Combine these readings to create a <code>SwerveModulePosition</code>.<br><br><strong>Implementation Note:</strong> Your swerve drivetrain template will have a <code>SwerveModule</code> class that handles reading from encoders and creating <code>SwerveModulePosition</code> objects. The template handles all the hardware-specific details - you just need to understand that each module reports distance and angle."
    },
    {
      "type": "code",
      "title": "Reading Drive Distance",
      "description": "Distance: How far the module's drive wheel has traveled (meters). The drive encoder measures how many rotations the drive wheel has made. Your drivetrain template handles the conversion from rotations to meters.",
      "content": "// Read drive encoder to get distance traveled\n// (Your drivetrain template handles conversion to meters)\ndouble distanceMeters = m_driveMotor.getPosition();  // Already converted to meters"
    },
    {
      "type": "code",
      "title": "Reading Steering Angle",
      "description": "Angle: The module's current steering angle (Rotation2d). The angle encoder (typically an absolute encoder like CANcoder) measures what direction the module is pointing. Absolute encoders give the current angle, not just a relative change.",
      "content": "// Read angle encoder to get steering direction\n// (Absolute encoder gives current angle, not relative)\nRotation2d angle = Rotation2d.fromRotations(m_angleEncoder.getPosition());"
    },
    {
      "type": "code",
      "title": "Creating SwerveModulePosition",
      "description": "Combine these readings to create a <code>SwerveModulePosition</code>. A swerve module needs to report two things for odometry: the distance traveled and the steering angle. These are combined into a single <code>SwerveModulePosition</code> object.",
      "content": "// Return both as SwerveModulePosition\npublic SwerveModulePosition getPosition() {\n    double distanceMeters = m_driveMotor.getPosition();\n    Rotation2d angle = Rotation2d.fromRotations(m_angleEncoder.getPosition());\n    \n    return new SwerveModulePosition(distanceMeters, angle);\n}"
    },
    {
      "type": "text",
      "title": "Odometry Limitations",
      "content": "Understanding odometry limitations is crucial for effective use:<br><br><strong>Drift:</strong> Odometry accumulates error over time. Small measurement errors compound, causing the pose estimate to drift from actual position. Drift increases with distance traveled and time. Typical drift: 1-5% of distance traveled.<br><br><strong>Wheel Slippage:</strong> When wheels slip (during acceleration, on slippery surfaces, during collisions), encoder readings don't match actual movement. Slippage causes immediate pose errors that persist until corrected.<br><br><strong>Accuracy Degradation Over Time:</strong> Without correction, odometry accuracy decreases over time. After long autonomous routines or extended operation, pose may be significantly off. This is why sensor fusion with vision is recommended for high-accuracy applications.<br><br><strong>Mitigation Strategies:</strong><br>- Use vision-based pose estimation to periodically correct drift<br>- Implement sensor fusion (see <a href='#vision-pose-estimation-complete' target='_blank'>Vision-Based Pose Estimation</a> lesson)<br>- Design mechanisms to minimize wheel slippage<br>- Calibrate wheel diameter and encoder settings accurately"
    },
    {
      "type": "text",
      "title": "Swerve-Specific Considerations",
      "content": "Swerve odometry has unique considerations compared to differential drive:<br><br><strong>Module Offsets:</strong> Module positions must be accurately measured relative to robot center. Incorrect offsets cause odometry errors. Measure track width and wheelbase carefully (in meters).<br><br><strong>Module Angle Accuracy:</strong> Swerve odometry requires accurate module angle measurements. Absolute encoders (like CANcoder) are strongly recommended for each module. Module angle errors directly affect odometry accuracy.<br><br><strong>Center of Rotation:</strong> Swerve robots can rotate around any point (not just center). Odometry assumes rotation around robot center, which is accurate for most cases.<br><br><strong>Accuracy Advantages:</strong> Swerve odometry is typically more accurate than differential drive because it uses four measurement points instead of two. However, it requires proper calibration of all four modules."
    },
    {
      "type": "code",
      "title": "Complete Swerve Odometry Flow",
      "content": "package frc.robot.subsystems;\n\nimport edu.wpi.first.math.geometry.Pose2d;\nimport edu.wpi.first.math.geometry.Rotation2d;\nimport edu.wpi.first.math.kinematics.SwerveDriveKinematics;\nimport edu.wpi.first.math.kinematics.SwerveDriveOdometry;\nimport edu.wpi.first.math.kinematics.SwerveModulePosition;\nimport edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class SwerveDrivetrain extends SubsystemBase {\n    // Hardware\n    private final Gyro m_gyro;\n    private final SwerveModule m_frontLeft;\n    private final SwerveModule m_frontRight;\n    private final SwerveModule m_rearLeft;\n    private final SwerveModule m_rearRight;\n    \n    // Odometry components\n    private final SwerveDriveKinematics m_kinematics;\n    private final SwerveDriveOdometry m_odometry;\n    private final SwerveModulePosition[] m_modulePositions = new SwerveModulePosition[4];\n    \n    public SwerveDrivetrain() {\n        // 1. Initialize hardware (your template handles this)\n        // Initialize modules and gyro...\n        \n        // 2. Set up kinematics (module positions)\n        // Create kinematics with module positions...\n        \n        // 3. Get initial module positions\n        updateModulePositions();\n        \n        // 4. Initialize odometry\n        m_odometry = new SwerveDriveOdometry(\n            m_kinematics,\n            Rotation2d.fromDegrees(m_gyro.getAngle()),\n            m_modulePositions,\n            new Pose2d()\n        );\n    }\n    \n    // PERIODIC: Called every robot loop (20ms)\n    @Override\n    public void periodic() {\n        // 1. Get current positions from all modules\n        updateModulePositions();\n        \n        // 2. Update odometry with new measurements\n        m_odometry.update(\n            Rotation2d.fromDegrees(m_gyro.getAngle()),\n            m_modulePositions\n        );\n        \n        // 3. (Optional) Display pose on SmartDashboard\n        Pose2d pose = m_odometry.getPoseMeters();\n        SmartDashboard.putNumber(\"Robot X\", pose.getX());\n        SmartDashboard.putNumber(\"Robot Y\", pose.getY());\n        SmartDashboard.putNumber(\"Robot Heading\", pose.getRotation().getDegrees());\n    }\n    \n    // HELPER: Update module positions array\n    private void updateModulePositions() {\n        m_modulePositions[0] = m_frontLeft.getPosition();\n        m_modulePositions[1] = m_frontRight.getPosition();\n        m_modulePositions[2] = m_rearLeft.getPosition();\n        m_modulePositions[3] = m_rearRight.getPosition();\n    }\n    \n    // GET POSE: Called by autonomous/teleop code\n    public Pose2d getPose() {\n        return m_odometry.getPoseMeters();\n    }\n    \n    // RESET: Called at start of autonomous or after vision correction\n    public void resetOdometry(Pose2d pose) {\n        updateModulePositions();\n        m_odometry.resetPosition(\n            Rotation2d.fromDegrees(m_gyro.getAngle()),\n            m_modulePositions,\n            pose\n        );\n    }\n}\n\n// KEY CONCEPTS:\n// 1. Constructor: Initialize once at startup\n// 2. Periodic: Update every loop (20ms) - this is critical!\n// 3. getPose: Use this to get current position\n// 4. resetOdometry: Use this to set a known position"
    },
    {
      "type": "text",
      "title": "Best Practices for Accurate Odometry",
      "content": "Following these practices ensures the most accurate odometry possible:<br><br><strong>Sensor Calibration:</strong><br>- Accurately measure and configure wheel diameter<br>- Accurately measure and configure track width / wheelbase<br>- Calibrate gyroscope properly<br>- For swerve: Calibrate all module angle offsets<br><br><strong>Update Frequency:</strong><br>- Call <code>updateOdometry()</code> in every <code>periodic()</code> call (20ms)<br>- Don't skip odometry updates - this is critical for accuracy<br>- Your drivetrain template handles efficient sensor reading<br><br><strong>Drift Mitigation:</strong><br>- Combine with vision for periodic corrections<br>- Reset odometry at start of autonomous<br>- Monitor odometry accuracy during testing<br><br><strong>Mechanical Considerations:</strong><br>- Minimize wheel slippage (proper wheel material, avoid aggressive acceleration)<br>- Ensure encoders are securely mounted<br>- Check for mechanical play in drivetrain"
    },
    {
      "type": "link-grid",
      "title": "Resources",
      "links": [
        {
          "label": "Pose Estimation Introduction",
          "id": "pose-estimation-intro"
        },
        {
          "label": "Vision-Based Pose Estimation",
          "id": "vision-pose-estimation-fusion"
        },
        {
          "label": "WPILib Kinematics and Odometry",
          "url": "https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/index.html"
        },
        {
          "label": "Sensors and Encoders",
          "id": "sensors-and-encoders"
        }
      ]
    }
  ]
}