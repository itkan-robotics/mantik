{
  "title": "Intake (Command-Based)",
  "sections": [
    {
      "type": "text",
      "title": "Overview",
      "content": "We will rebuild the intake using the command-based framework. This involves:<br>1. <strong>Subsystem:</strong> Encapsulates the motor.<br>2. <strong>Commands:</strong> Define actions (run/stop).<br>3. <strong>RobotContainer:</strong> Binds buttons."
    },
    {
      "type": "code-tabs",
      "title": "1. Subsystem",
      "content": "The subsystem handles hardware configuration and low-level control.",
      "tabs": [
        {
          "label": "Talon FX",
          "code": "package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport com.ctre.phoenix6.hardware.TalonFX;\nimport com.ctre.phoenix6.configs.TalonFXConfiguration;\nimport com.ctre.phoenix6.signals.NeutralModeValue;\nimport com.ctre.phoenix6.controls.DutyCycleOut;\n\npublic class Intake extends SubsystemBase {\n    // Intake motor on CAN ID 5\n    private final TalonFX m_motor = new TalonFX(5);\n    private final DutyCycleOut m_out = new DutyCycleOut(0);\n\n    public Intake() {\n        // Configure motor for intake use\n        TalonFXConfiguration config = new TalonFXConfiguration();\n        // Coast mode allows free spinning when stopped\n        config.MotorOutput.NeutralMode = NeutralModeValue.Coast;\n        // Enable current limiting to protect motor\n        config.CurrentLimits.StatorCurrentLimitEnable = true;\n        config.CurrentLimits.StatorCurrentLimit = 30.0;\n        m_motor.getConfigurator().apply(config);\n    }\n\n    /**\n     * Run the intake at the specified speed\n     * @param speed Motor speed (-1.0 to 1.0, positive = collect)\n     */\n    public void run(double speed) {\n        m_motor.setControl(m_out.withOutput(speed));\n    }\n\n    /**\n     * Stop the intake motor\n     */\n    public void stop() {\n        m_motor.setControl(m_out.withOutput(0.0));\n    }\n}"
        },
        {
          "label": "SPARK MAX",
          "code": "package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport com.revrobotics.spark.SparkMax;\nimport com.revrobotics.spark.SparkLowLevel.MotorType;\nimport com.revrobotics.spark.config.SparkMaxConfig;\nimport com.revrobotics.spark.config.SparkBaseConfig.IdleMode;\nimport com.revrobotics.spark.SparkBase.ResetMode;\nimport com.revrobotics.spark.SparkBase.PersistMode;\n\npublic class Intake extends SubsystemBase {\n    // Intake motor on CAN ID 5, brushless type\n    private final SparkMax m_motor = new SparkMax(5, MotorType.kBrushless);\n\n    public Intake() {\n        // Configure motor for intake use\n        SparkMaxConfig config = new SparkMaxConfig();\n        // Coast mode allows free spinning when stopped\n        config.idleMode(IdleMode.kCoast);\n        // Enable current limiting to protect motor\n        config.smartCurrentLimit(30);\n        m_motor.configure(config, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);\n    }\n\n    /**\n     * Run the intake at the specified speed\n     * @param speed Motor speed (-1.0 to 1.0, positive = collect)\n     */\n    public void run(double speed) {\n        m_motor.set(speed);\n    }\n\n    /**\n     * Stop the intake motor\n     */\n    public void stop() {\n        m_motor.set(0.0);\n    }\n}"
        }
      ]
    },
    {
      "type": "code",
      "title": "2. RobotContainer",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Commands;\nimport edu.wpi.first.wpilibj2.command.button.CommandXboxController;\nimport frc.robot.subsystems.Intake;\n\npublic class RobotContainer {\n    // Create subsystem instance\n    private final Intake m_intake = new Intake();\n    // Create controller on USB port 1\n    private final CommandXboxController m_controller = new CommandXboxController(1);\n\n    public RobotContainer() {\n        // Default command: Stop intake when no other command is running\n        m_intake.setDefaultCommand(Commands.run(() -> m_intake.stop(), m_intake));\n\n        // Button bindings\n        // Button A: Run intake forward (collect) while held\n        m_controller.a().whileTrue(Commands.run(() -> m_intake.run(0.6), m_intake));\n        // Button B: Run intake reverse (eject) while held\n        m_controller.b().whileTrue(Commands.run(() -> m_intake.run(-0.4), m_intake));\n    }\n}"
    },
    {
      "type": "text",
      "title": "3. Robot.java",
      "content": "Update <code>Robot.java</code> to run the scheduler."
    },
    {
      "type": "code",
      "title": "Robot.java Updates",
      "content": "package frc.robot;\n\nimport edu.wpi.first.wpilibj.TimedRobot;\nimport edu.wpi.first.wpilibj2.command.CommandScheduler;\n\npublic class Robot extends TimedRobot {\n    private RobotContainer m_container;\n\n    @Override\n    public void robotInit() {\n        // Create RobotContainer to initialize subsystems and bindings\n        m_container = new RobotContainer();\n    }\n\n    @Override\n    public void robotPeriodic() {\n        // Run the command scheduler every loop (essential for command-based)\n        CommandScheduler.getInstance().run();\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "Benefits",
      "subtitle": "Why this is better:",
      "items": [
        "<strong>Encapsulation:</strong> Hardware details are hidden in the Subsystem.",
        "<strong>Readability:</strong> RobotContainer clearly shows controls.",
        "<strong>Safety:</strong> Default commands ensure motors stop.",
        "<strong>Flexibility:</strong> Easy to reuse the intake in Auto."
      ]
    },
    {
      "type": "link-grid",
      "title": "Related",
      "links": [
        {
          "label": "Command-Based Intro",
          "id": "intro-to-command-based"
        },
        {
          "label": "PID Control",
          "id": "pid-control"
        }
      ]
    }
  ]
}
