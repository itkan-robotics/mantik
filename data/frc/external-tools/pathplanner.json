{
      "title": "PathPlanner: Visual Autonomous Routines",
  "sections": [
    {
      "type": "text",
      "title": "What is PathPlanner?",
      "content": "PathPlanner is a motion profile generator and autonomous path planning tool for FRC robots. It allows you to draw paths on a field map, configure robot constraints (max velocity, acceleration), and automatically generate smooth trajectories. It integrates seamlessly with WPILib via <a href='https://pathplanner.dev/api/java/' target='_blank'>PathPlannerLib</a> to follow these paths in code.<br><br>The modern workflow uses <strong><a href='https://pathplanner.dev/api/java/com/pathplanner/lib/auto/AutoBuilder.html' target='_blank'>AutoBuilder</a></strong>, which automatically generates commands to follow paths and trigger event markers (like \"Intake\" or \"Shoot\") defined in the GUI.<br><br>Learn more: <a href='https://pathplanner.dev/home.html' target='_blank'>PathPlanner Documentation</a> | <a href='https://pathplanner.dev/api/java/' target='_blank'>PathPlannerLib API</a>"
    },
    {
      "type": "text",
      "title": "AutoBuilder",
      "content": "The <strong>AutoBuilder</strong> library connects PathPlanner to your robot code. You configure it once in your Drive subsystem, and then you can load any path or full auto routine with a single line of code."
    },
    {
      "type": "code",
      "title": "AutoBuilder Configuration (Swerve)",
      "content": "import com.pathplanner.lib.auto.AutoBuilder;\nimport com.pathplanner.lib.util.HolonomicPathFollowerConfig;\nimport com.pathplanner.lib.util.PIDConstants;\nimport com.pathplanner.lib.util.ReplanningConfig;\n\npublic class Drivetrain extends SubsystemBase {\n    public Drivetrain() {\n        // ... hardware init ...\n\n        // API: AutoBuilder.configureHolonomic() - https://pathplanner.dev/api/java/com/pathplanner/lib/auto/AutoBuilder.html\n        AutoBuilder.configureHolonomic(\n                this::getPose,          // Supplier<Pose2d> function to supply current robot pose\n                this::resetPose,        // Consumer<Pose2d> function to reset the pose\n                this::getRobotRelativeSpeeds, // Supplier<ChassisSpeeds> current speeds\n                this::driveRobotRelative,     // Consumer<ChassisSpeeds> output for driving\n                // API: HolonomicPathFollowerConfig - https://pathplanner.dev/api/java/com/pathplanner/lib/util/HolonomicPathFollowerConfig.html\n                new HolonomicPathFollowerConfig(\n                        // API: PIDConstants - https://pathplanner.dev/api/java/com/pathplanner/lib/util/PIDConstants.html\n                        new PIDConstants(5.0, 0.0, 0.0), // Translation PID constants\n                        new PIDConstants(5.0, 0.0, 0.0), // Rotation PID constants\n                        4.5,                             // Max module speed (m/s)\n                        0.4,                             // Drive base radius (m) (distance from center to furthest module)\n                        // API: ReplanningConfig - https://pathplanner.dev/api/java/com/pathplanner/lib/util/ReplanningConfig.html\n                        new ReplanningConfig()           // Default path replanning config\n                ),\n                () -> {\n                    // Boolean supplier that controls when the path will be mirrored for the red alliance\n                    // This will flip the path being followed to the red side of the field.\n                    // THE ORIGIN WILL REMAIN ON THE BLUE SIDE\n                    var alliance = DriverStation.getAlliance();\n                    if (alliance.isPresent()) {\n                        return alliance.get() == DriverStation.Alliance.Red;\n                    }\n                    return false;\n                },\n                this // Reference to this subsystem to set requirements\n        );\n    }\n}"
    },
    {
      "type": "text",
      "title": "Creating and Running Paths",
      "content": "Once configured, you can load paths or full autos by name. PathPlanner files are deployed to the robot's \"deploy/pathplanner\" directory."
    },
    {
      "type": "code",
      "title": "Loading Paths",
      "content": "// In RobotContainer.java\n\n// API: AutoBuilder.buildAuto() - https://pathplanner.dev/api/java/com/pathplanner/lib/auto/AutoBuilder.html#buildAuto(java.lang.String)\n// Build an auto command from a named \"Auto\" file in the GUI\nCommand myAuto = AutoBuilder.buildAuto(\"My Two Piece Auto\");\n\n// API: AutoBuilder.followPath() - https://pathplanner.dev/api/java/com/pathplanner/lib/auto/AutoBuilder.html#followPath(com.pathplanner.lib.path.PathPlannerPath)\n// API: PathPlannerPath.fromPathFile() - https://pathplanner.dev/api/java/com/pathplanner/lib/path/PathPlannerPath.html#fromPathFile(java.lang.String)\n// Or, follow a single path\nCommand followPath = AutoBuilder.followPath(PathPlannerPath.fromPathFile(\"Taxi Path\"));\n\n// API: AutoBuilder.buildAutoChooser() - https://pathplanner.dev/api/java/com/pathplanner/lib/auto/AutoBuilder.html#buildAutoChooser()\n// Add to SmartDashboard chooser\nSendableChooser<Command> autoChooser = AutoBuilder.buildAutoChooser();\nSmartDashboard.putData(\"Auto Chooser\", autoChooser);"
    },
    {
      "type": "text",
      "title": "Event Markers and Named Commands",
      "content": "To use Event Markers, you must register your commands with <a href='https://pathplanner.dev/api/java/com/pathplanner/lib/auto/NamedCommands.html' target='_blank'>NamedCommands</a> <strong>before</strong> building the auto. This maps the string names in the PathPlanner GUI to actual Java commands. See <a href='https://pathplanner.dev/pplib-overview/using-event-markers' target='_blank'>Event Markers Documentation</a>."
    },
    {
      "type": "code",
      "title": "Registering Named Commands",
      "content": "import com.pathplanner.lib.auto.NamedCommands;\n\npublic class RobotContainer {\n    public RobotContainer() {\n        // API: NamedCommands.registerCommand() - https://pathplanner.dev/api/java/com/pathplanner/lib/auto/NamedCommands.html#registerCommand(java.lang.String,edu.wpi.first.wpilibj2.command.Command)\n        // Register Named Commands\n        NamedCommands.registerCommand(\"intake\", new IntakeCommand(m_intake));\n        NamedCommands.registerCommand(\"shoot\", new ShootCommand(m_shooter));\n        NamedCommands.registerCommand(\"stop\", Commands.runOnce(m_intake::stop));\n\n        // Now build the auto\n        autoChooser = AutoBuilder.buildAutoChooser();\n    }\n}"
    },
    {
      "type": "rules-box",
      "title": "PathPlanner Tips",
      "subtitle": "Best practices for success:",
      "items": [
        "Always measure your robot's max velocity and acceleration accurately.",
        "Tune PID constants in the <a href='https://pathplanner.dev/api/java/com/pathplanner/lib/util/HolonomicPathFollowerConfig.html' target='_blank'>HolonomicPathFollowerConfig</a>; start low and increase.",
        "Use 'On-the-fly' generation for dynamic pathing if needed, but pre-generated paths are safer.",
        "Visualize path following in AdvantageScope or Field2d to debug tracking errors.",
        "Remember to register <a href='https://pathplanner.dev/api/java/com/pathplanner/lib/auto/NamedCommands.html' target='_blank'>NamedCommands</a> before building the auto chooser."
      ]
    },
    {
      "type": "link-grid",
      "title": "Related Topics",
      "links": [
        {
          "label": "PathPlanner Docs",
          "url": "https://pathplanner.dev/"
        },
        {
          "label": "PathPlannerLib API",
          "url": "https://pathplanner.dev/api/java/"
        },
        {
          "label": "Command-Based Programming",
          "id": "command-based-intro"
        },
        {
          "label": "Pose Estimation",
          "id": "pose-estimation-intro"
        }
      ]
    }
  ]
}